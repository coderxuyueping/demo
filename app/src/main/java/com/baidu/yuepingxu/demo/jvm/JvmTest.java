package com.baidu.yuepingxu.demo.jvm;

/**
 * @author xuyueping
 * @date 2020-03-24
 * @describe jvm内存模型和jmm模型无关（jmm是并发模型）
 *
 *   ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 *   |                                              运行时数据区（jvm内存结构）                                           |
 *   |                                                                                                                 |
 *   | ——————————————————————————                                                                                      |
 *   ||                           |                    ————————————————————     ——————————————————                     |
 *   ||                           |                   |                    |    |                 |                    |
 *   ||       Heap（堆）  共有     |                   |    stack（虚拟机栈） |    |  native method  |                    |
 *   ||                           |                   |    线程私有         |    |   本地方法栈     |                     |
 *   ||                           |                   |                    |    |  线程私有        |                    |
 *   | ————————————————————————————                     ————————————————————      ————————————————                     |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |   ——————————————————————————                                                                                    |
 *   ||                           |                       _________________________________________                    |
 *   ||                           |                       |                                         |                  |
 *   ||       方法区     共有       |                      |          程序计数器 线程私有               |                  |
 *   ||                           |                       |                                         |                  |
 *   ||                           |                       |                                         |                  |
 *   | ————————————————————————————                       |________________________________________ |                  |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   |                                                                                                                 |
 *   ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 *
 *
 *
 *   程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，
 *   指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，
 *   来获取下一条需要执行的字节码指令，从而确保线程的正确执行。
 * 为了确保线程切换后（上下文切换）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。
 * 也就是说程序计数器是线程私有的内存
 *
 * 栈中存储的是栈帧，每个方法在执行时都会创建一个栈帧。栈帧中存储了局部变量表、操作数栈、动态连接和方法出口等信息。
 * 每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。
 * 局部变量表
 * 栈帧中，由一个局部变量表存储数据。局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、
 * 和对象的引用（String、数组、对象等），但是不存储对象的内容。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。
 *
 * 操作数栈是一个后进先出栈。操作数栈的元素可以是任意的Java数据类型。方法刚开始执行时，操作数栈是空的，在方法执行过程中，
 * 通过字节码指令对操作数栈进行压栈和出栈的操作。通常进行算数运算的时候是通过操作数栈来进行的，
 * 又或者是在调用其他方法的时候通过操作数栈进行参数传递。操作数栈可以理解为栈帧中用于计算的临时数据存储区。
 *
 *
 * 堆是Java虚拟机所管理的内存中最大的一块存储区域。堆内存被所有线程共享。主要存放使用new关键字创建的对象。
 * 所有对象实例以及数组都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间（收集的是对象占用的空间而不是对象本身）。
 * Java堆分为年轻代（Young Generation）和老年代（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；
 * 幸存区又分为From Survivor空间和 To Survivor空间。
 * 年轻代存储“新生对象”，我们新创建的对象存储在年轻代中。当年轻内存占满后，会触发Minor GC，清理年轻代内存空间。
 *
 * 老年代存储长期存活的对象和大对象。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发Full GC。
 *
 * 注：Full GC是清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出OutOfMemoryError异常。
 * 在新生代满了后发生yongGC，用引用计数法或者GCRoot法判断是否要回收，活下来的进入到From，之后再GC进入To，每经过一次GC活下来年龄加1，超过15进入年老代
 * 年老代发生的Gc是FUllGC
 *
 *
 * 方法区同 Java 堆一样是被所有线程共享的区间，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。更具体的说，
 * 静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分。
 * 常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
 *
 *
 * GC算法
 * 标记清除算法
 * 从根集开始对有引用的对象进行标记，之后没有标记的清除，缺点是标记和清除的效率不是很高，并且会产生很多碎片空间，对下次需要申请大的连续空间
 * 不利，会提前触发GC
 *
 * 复制算法
 * 将内存空间分成两块，一块进行使用，在将存活的对象放到未使用的那块，另外那块进行清理，这种算法适用于对象存活率低的场景，比如新生代
 * 不会产生不连续的内存空间
 *
 * 标记整理
 * 类似标记清除，但是清除后会将空间进行整理，不会产生不连续空间 该垃圾回收算法适用于对象存活率高的场景（老年代）
 *
 * 分代收集算法
 * 新生代年老代
 */
public class JvmTest {
    public static void main(String[] args) {

    }
}
